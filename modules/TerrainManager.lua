-- todo
-- implement chunk kind queue
-- implement chunk querying

TerrainManager = class{
	
	init = function(self, objects, controller)

		self.chunks = ChunkManager(objects)
		self.controller = controller

		-- create the sky manager
		local sky = SkyManager()
		objects:add(sky)

		-- create the ground collider
		local ground = Ground(window.height - world.floor)
		objects:add(ground)

		-- seperates the unbatched text from score tokens from the terrain
		local seperator = Seperator()
		objects:add(seperator)

	end,

	update = function(self, dt)

		-- get the viewport position and dimensions
		local x, y, z = self.controller:get()
		local w, h, padding = window.width, window.height, window.padding

		-- set the bound for chunk trimming and appending
		local bound = {
			left = x - (w / 2) - padding,
			right = x + (w / 2) + padding,
		}

		-- append and trim chunks based on the viewport bound
		self.chunks:append(bound.right)
		self.chunks:trim(bound.left)

	end,

	-- queue a chunk type for creation
	-- by default chunk manager will make eat chunks
	-- this is used for making a nap zone or other scenery changes
	-- this should allow for multiple chunk types to be queued
	queue = function(self, kind)
		self.chunks:queue(kind)
	end,
}

ChunkManager = class{
	
	init = function(self, objects)

		self.objects = objects
		self.groups = GroupManager(objects)
		self.chunks = {}
		self.stack = {'start'}

	end,

	add = function(self)

		local chunks, previous, position, size, chunk, marker, kind, keys
		chunks = self.chunks

		-- get the last chunk in chunks
		previous = chunks[#chunks]

		-- if this is the first chunk is being added, seed a starting position and size
		if not previous then
			previous = {
				position = {
					x = 0,
					y = 0,
					z = 1,
				},
				size = {
					w = 0,
					h = 0,
				}
			}
		end

		-- place the new chunk to the right of the last one
		position = {
			x = previous.position.x + previous.size.w,
			y = previous.position.y,
			z = previous.position.z
		}

		-- temporary size
		-- what size is actually going to be appropriate?
		-- twice the window length means that removal will be one screen width out of phase
		-- with addition, but that's only assuming that handling more objects at once is problematic

		-- the size of chunks seems to have pretty substantial perf implications
		size = {
			w = 1024,
			h = window.height,
		}

		local queue = self.stack
		if (#queue > 0) then
			kind = queue[1]
			table.remove(queue, 1)
		else
			kind = 'eat'
		end

		if kind == 'start' then

			local w = window.width * 0.7
			local bound = {
				left = position.x,
				right = position.x + w,
				top = position.y,
				bottom = position.y + size.h
			}
			
			observer:emit('void', bound)

		end

		-- format the chunk attributes for the chunks list
		chunk = {
			position = position,
			size = size,
			kind = kind,
			keys = nil,
			seed = nil,
		}

		-- build the chunk
		self:build(chunk)

		local renderer = g["renderer"]
		renderer.flag = true

	end,

	-- builds a chunk specified by the args and returns a list of keys generated
	build = function(self, chunk)

		-- os.time is in seconds, so I'm using a random number from the last seed to mix things up
		chunk.seed = math.floor(1000000 * math.random())
		math.randomseed(chunk.seed)

		local keys, key, marker
		keys = {}

		local variants, variant, groups
		
		-- get the chunk variants for selected kind
		variants = templates.chunks[chunk.kind]
		if variants then

			-- choose the chunk variant using weighted random selection
			variant = wchoose(variants)
			if variant then

				-- generate object groups for this chunk
				groups = variants[variant].groups

				for j, group in ipairs(groups) do

					local batch = self.groups:build(group, chunk)
					if batch then

						-- add generated objects to keys
						for i, object in ipairs(batch) do
							table.insert(keys, object)
						end

					end

				end

				-- store the keys in the chunk's list
				chunk.keys = keys

				-- register the generated chunk in the manager
				table.insert(self.chunks, chunk)

				-- debug text
				-- print('built a ' .. chunk.kind .. ' chunk with seed ' .. chunk.seed)

			else
				error('attempted to build ' .. chunk.kind .. ' chunk but was unable to choose a valid variant.')
			end

		else
			error('attempted to build invalid chunk: ' .. tostring(chunk.kind))
		end



		if settings.debug or true then

			local label

			label = chunk.kind .. ': ' .. chunk.seed .. ' (' .. comma_value(chunk.position.x) .. ', ' .. comma_value(chunk.position.y) .. ')'

			--[[
			-- display the object keys generated by this chunk
			if chunk.keys then
				label = label .. '\n\nkeys:\n'
				for i = 1, #chunk.keys do
					label = label .. chunk.keys[i] .. '\n'
				end
			end
			]]--

			-- add a marker for the chunk into the objects (temporary)
			--marker = Outline(chunk.position, chunk.size, label)
			--key = self.objects:add(marker)
			--table.insert(keys, key)
			-- end of temp marker

		end

	end,

	-- returns a list of bounds that should be infertile for edibles
	occupied = function(self, bound)

		-- todo determine when and how this will get called (yes/no args?)
		-- check chunks for intertile zones inside of the bound (I probably need to check all of the chunks)

	end,

	-- 
	query = function(self, bound)

	end,

	-- add a chunk type to the queue
	queue = function(self, kind)

		if kind then
			table.insert(self.stack, kind)
		end

	end,

	-- removes the leading chunk from the list
	trim = function(self, edge)

		local chunks
		chunks = self.chunks

		for key = 1, #chunks do
			if self:valid(key) then

				local position, size
				position = chunks[key].position
				size = chunks[key].size

				if (edge > position.x + size.w) then
					self:remove(key)					
				end

			end
		end

	end,

	-- add a new chunk if no chunks exist past the passed edge position
	append = function(self, edge)

		local chunks, populated
		chunks = self.chunks

		while not populated do

			local void
			for key = 1, #chunks do
				if self:valid(key) then

					local position
					position = chunks[key].position
					size = chunks[key].size

					if (edge < position.x + size.w) then
						void = true
					end

				end
			end

			if void then

				populated = true
				break

			else
				self:add()
			end

		end

	end,

	-- remove a chunk by key
	remove = function(self, key)

		local chunks, groups, chunk, skip
		chunks = self.chunks
		groups = self.groups

		if key then

			chunk = chunks[key]

			-- if the key refers to a valid chunk
			if self:valid(key) then

				-- this will return any leftover keys, that should be transferred to the neighboring chunk
				local leftover, neighbor
				leftover = groups:remove(chunk)

				neighbor = math.min(key + 1, #chunks)

				if leftover then

					if self:valid(neighbor) then

						-- if this is the last chunk, remove the leftovers as well
						if (key == #chunks) then

							self.objects:remove(leftover)
							self.groups:release(leftover)

						else

							-- otherwise, add them to the neighboring chunk
							for i = 1, #leftover do
								table.insert(chunks[neighbor].keys, leftover[i])
							end

						end

					end

				end

				-- set the chunk to the next plausible valid chunk for faster future traversal
				--skip = math.min(key + 1, #chunks)
				--chunks[key] = skip

				-- try just removing the darn thing
				table.remove(chunks, key)

				-- debug text
				-- print('removed a chunk: ' .. key .. ', and set the next valid chunk to ' .. chunks[key])

			else

				print('tried to remove an invalid or already deactivated chunk using key ' .. tostring(key))

			end

		end

	end,

	-- returns true if key refers to a valid chunk in the chunks list
	valid = function(self, key)
		return self.chunks[key] and (type(self.chunks[key]) ~= 'number')
	end,

}